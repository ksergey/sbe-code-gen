{% macro define_enum(type, schema) %}
  {% set enum_class_name = type.name | format_enum_name %}
class {{ enum_class_name }}(Enum):
  {% for valid_value in type.valid_values %}
    {% if type.encoding_type.name == 'char' %}
    {{ valid_value.name | format_constant_name }} = '{{ valid_value.value }}'
    {% else %}
    {{ valid_value.name | format_constant_name }} = {{ valid_value.value }}
    {% endif %}
  {% endfor %}
{% endmacro %}

{% macro define_set(type, schema) %}
  {% set set_class_name = type.name | format_set_name %}
class {{ set_class_name }}(Flag):
  {% for choice in type.choices %}
    {{ choice.name | format_constant_name }} = {{ choice.value | bit_to_value}}
  {% endfor %}
{% endmacro %}

{% macro make_encoding__suffix(field) -%}
  {% if field.reference_name %}
{{- field.reference_name -}}
  {% else %}
{{- field.name -}}
  {% endif %}
{%- endmacro %}

{% macro encoding_type__define_pack(field, schema) %}
  {% set type = field.type if field.token == 'field' else field -%}
  {% set primitive_type = type.primitive_type -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}
  {% set is_string = primitive_type.name == 'char' -%}
  {% set is_optional = field.presence == 'optional' -%}

  {% if field.presence == 'required' and type.length == 1 %}
def pack_{{ make_encoding__suffix(field) }}(v):
    struct.pack_into('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }}, v)
  {% endif %}
  {% if field.presence == 'optional' and type.length == 1 %}
def pack_{{ make_encoding__suffix(field) }}(v):
    struct.pack_into('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }}, v if v else {{ type.null_value | replace_keyword }})
  {% endif %}
  {% if field.presence == 'required' and type.length > 1 %}
    {% if is_string %}
def pack_{{ make_encoding__suffix(field) }}(v):
    raw_value = v.encode('utf-8')
    assert len(raw_value) <= {{ type.length }}, 'argument length mismatch'
    if len(raw_value) < {{ type.length }}:
        raw_value += b'\{{ type.null_value | replace_keyword }}' * ({{ type.length }} - len(raw_value))
    struct.pack_into('{{ type.length }}s', ctx.buffer, ctx.offset + {{ field.offset }}, raw_value)
    {% else %}
def pack_{{ make_encoding__suffix(field) }}(v):
    assert len(v) == {{ type.length }}, 'argument length mismatch'
    struct.pack_into('{{ byte_order_flag }}{{ type.length }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }}, *v)
    {% endif %}
  {% endif %}
  {% if field.presence == 'optional' and type.length > 1 %}
    {% if is_string %}
def pack_{{ make_encoding__suffix(field) }}(v):
    if v:
        raw_value = v.encode('utf-8')
        assert len(raw_value) <= {{ type.length }}, 'argument length mismatch'
    else:
        raw_value = b''
    if len(raw_value) < {{ type.length }}:
        raw_value += b'\{{ type.null_value | replace_keyword }}' * ({{ type.length }} - len(raw_value))
    struct.pack_into('{{ type.length }}s', ctx.buffer, ctx.offset + {{ field.offset }}, raw_value)
    {% else %}
def pack_{{ make_encoding__suffix(field) }}(v):
    if v:
        assert len(v) == {{ type.length }}, 'argument length mismatch'
        struct.pack_into('{{ byte_order_flag }}{{ type.length }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }}, *v)
    else:
        struct.pack_into('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }}, {{ type.null_value | replace_keyword }})
    {% endif %}
  {% endif %}
  {% if field.presence == 'constant' %}
    {% if is_string %}
def pack_{{ make_encoding__suffix(field) }}(v):
    assert not v or v == '{{ type.const_value }}'
    {% else %}
def pack_{{ make_encoding__suffix(field) }}(v):
    assert not v or v == {{ type.const_value | replace_keyword }}
    {% endif %}
  {% endif %}
{% endmacro %}

{% macro encoding_type__invoke_pack(field, schema, arg_expr) %}
pack_{{ make_encoding__suffix(field) }}({{ arg_expr }})
{% endmacro %}

{% macro encoding_type__define_unpack(field, schema) %}
  {% set type = field.type if field.token == 'field' else field -%}
  {% set primitive_type = type.primitive_type -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}
  {% set is_string = primitive_type.name == 'char' -%}
  {% set is_optional = field.presence == 'optional' -%}

  {% if field.presence == 'required' and type.length == 1 %}
def unpack_{{ make_encoding__suffix(field) }}():
    return struct.unpack_from('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }})[0]
  {% endif %}
  {% if field.presence == 'optional' and type.length == 1 %}
def unpack_{{ make_encoding__suffix(field) }}():
    raw_value = struct.unpack_from('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }})[0]
    return raw_value if raw_value != {{ type.null_value | replace_keyword }} else None
  {% endif %}
  {% if field.presence == 'required' and type.length > 1 %}
    {% if is_string %}
def unpack_{{ make_encoding__suffix(field) }}():
    raw_value = struct.unpack_from('{{ type.length }}s', ctx.buffer, ctx.offset + {{ field.offset }})[0]
    return raw_value.decode('utf-8').rstrip(chr({{ type.null_value | replace_keyword }}))
    {% else %}
def unpack_{{ make_encoding__suffix(field) }}():
    return list(struct.unpack_from('{{ byte_order_flag }}{{ type.length }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }}))
    {% endif %}
  {% endif %}
  {% if field.presence == 'optional' and type.length > 1 %}
    {% if is_string %}
def unpack_{{ make_encoding__suffix(field) }}():
    raw_value = struct.unpack_from('{{ type.length }}s', ctx.buffer, ctx.offset + {{ field.offset }})[0]
    if raw_value[0] == chr({{ type.null_value | replace_keyword }}):
        return None
    return raw_value.decode('utf-8').rstrip(chr({{ type.null_value | replace_keyword }}))
    {% else %}
def unpack_{{ make_encoding__suffix(field) }}():
    raw_value = struct.unpack_from('{{ byte_order_flag }}{{ type.length }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }})
    return list(raw_value) if raw_value[0] != {{ type.null_value | replace_keyword }} else None
    {% endif %}
  {% endif %}
  {% if field.presence == 'constant' %}
    {% if is_string %}
def unpack_{{ make_encoding__suffix(field) }}():
    return '{{ type.const_value }}'
    {% else %}
def unpack_{{ make_encoding__suffix(field) }}():
    return {{ type.const_value | replace_keyword }}
    {% endif %}
  {% endif %}
{% endmacro %}

{% macro encoding_type__invoke_unpack(field, schema) %}
unpack_{{ make_encoding__suffix(field) }}()
{% endmacro %}

{% macro encoding_enum__define_pack(field, schema) %}
  {% set type = field.type if field.token == 'field' else field -%}
  {% set primitive_type = type.encoding_type -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}

  {% if field.presence == 'required' %}
def pack_{{ make_encoding__suffix(field) }}(v):
    assert isinstance(v, Enum)
    struct.pack_into('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }}, v.value)
  {% endif %}
  {% if field.presence == 'optional' %}
def pack_{{ make_encoding__suffix(field) }}(v):
    assert not v or isinstance(v, Enum)
    struct.pack_into('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }}, v.value if v else {{ type.null_value | replace_keyword }})
  {% endif %}
  {% if field.presence == 'constant' %}
    {% set enum_name = field.value_ref.split('.')[0] %}
    {% set enum_value = field.value_ref.split('.')[1] %}
def pack_{{ make_encoding__suffix(field) }}(v):
    assert not v or v == {{ enum_name | format_enum_name }}.{{ enum_value | format_constant_name }}
  {% endif %}
{% endmacro %}

{% macro encoding_enum__invoke_pack(field, schema, arg_expr) %}
pack_{{ make_encoding__suffix(field) }}({{ arg_expr }})
{% endmacro %}

{% macro encoding_enum__define_unpack(field, schema) %}
  {% set type = field.type if field.token == 'field' else field -%}
  {% set primitive_type = type.encoding_type -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}

  {% if field.presence == 'required' %}
def unpack_{{ make_encoding__suffix(field) }}():
    return {{ type.name | format_enum_name }}(struct.unpack_from('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }})[0])
  {% endif %}
  {% if field.presence == 'optional' %}
def unpack_{{ make_encoding__suffix(field) }}():
    raw_value = struct.unpack_from('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }})[0]
    if raw_value == {{ type.null_value | replace_keyword }}:
        return None
    return {{ type.name | format_enum_name }}(raw_value)
  {% endif %}
  {% if field.presence == 'constant' %}
    {% set enum_name = field.value_ref.split('.')[0] %}
    {% set enum_value = field.value_ref.split('.')[1] %}
def unpack_{{ make_encoding__suffix(field) }}():
    return {{ enum_name | format_enum_name }}.{{ enum_value | format_constant_name }}
  {% endif %}
{% endmacro %}

{% macro encoding_enum__invoke_unpack(field, schema) %}
unpack_{{ make_encoding__suffix(field) }}()
{% endmacro %}

{% macro encoding_set__define_pack(field, schema) %}
  {% set type = field.type if field.token == 'field' else field -%}
  {% set primitive_type = type.encoding_type -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}

  {% if field.presence == 'required' %}
def pack_{{ make_encoding__suffix(field) }}(v):
    assert isinstance(v, Flag)
    struct.pack_into('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }}, v.value)
  {% endif %}
{% endmacro %}

{% macro encoding_set__invoke_pack(field, schema, arg_expr) %}
pack_{{ make_encoding__suffix(field) }}({{ arg_expr }})
{% endmacro %}

{% macro encoding_set__define_unpack(field, schema) %}
  {% set type = field.type if field.token == 'field' else field -%}
  {% set primitive_type = type.encoding_type -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}

  {% if field.presence == 'required' %}
def unpack_{{ make_encoding__suffix(field) }}():
    return {{ type.name | format_set_name }}(struct.unpack_from('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }})[0])
  {% endif %}
{% endmacro %}

{% macro encoding_set__invoke_unpack(field, schema) %}
unpack_{{ make_encoding__suffix(field) }}()
{% endmacro %}

{% macro encoding_composite__define_pack(field, schema) %}
  {% set type = field.type if field.token == 'field' else field -%}
  {% set is_optional = field.presence == 'optional' -%}

def pack_{{ make_encoding__suffix(field) }}(v):
  {% for field in type.contained_types %}
    {{ encoding__define_pack(field, schema).strip() | indent(4) }}
  {% endfor %}

  {% if is_optional %}
    if not v:
        {{ encoding__invoke_pack(type.contained_types[0], schema, 'None').strip() | indent(8) }}
        return
  {% endif %}
  {% for field in type.contained_types %}
    {% if field.presence in ('optional', 'constant') %}
    {{ encoding__invoke_pack(field, schema, 'value.get(\'' ~ field.reference_name ~ '\', None)').strip() | indent(4) }}
    {% elif field.presence == 'required' %}
    {{ encoding__invoke_pack(field, schema, 'value.get(\'' ~ field.reference_name ~ '\')').strip() | indent(4) }}
    {% endif %}
  {% endfor %}
{% endmacro %}

{% macro encoding_composite__invoke_pack(field, schema, arg_expr) %}
pack_{{ make_encoding__suffix(field) }}({{ arg_expr }})
{% endmacro %}

{% macro encoding_composite__define_unpack(field, schema) %}
  {% set type = field.type if field.token == 'field' else field -%}
  {% set is_optional = field.presence == 'optional' -%}

def unpack_{{ make_encoding__suffix(field) }}():
  {% for field in type.contained_types %}
    {{ encoding__define_unpack(field, schema).strip() | indent(4) }}
  {% endfor %}

    value0 = {{ encoding__invoke_unpack(type.contained_types[0], schema).strip() }}
  {% if is_optional %}
    if not value0:
        return None
  {% endif %}
    value = { '{{ type.contained_types[0].reference_name }}': value0 }
  {% for field in type.contained_types %}
    {% if loop.index0 != 0 %}
    value['{{ field.reference_name }}'] = {{ encoding__invoke_unpack(field, schema).strip() }}
    {% endif %}
  {% endfor %}
    return value
{% endmacro %}

{% macro encoding_composite__invoke_unpack(field, schema) %}
unpack_{{ make_encoding__suffix(field) }}()
{% endmacro %}

{% macro encoding__define_pack(type, schema) %}
  {% if type.token == 'type' %}
{{ encoding_type__define_pack(type, schema) }}
  {% elif type.token == 'enum' %}
{{ encoding_enum__define_pack(type, schema) }}
  {% elif type.token == 'set' %}
{{ encoding_set__define_pack(type, schema) }}
  {% elif type.token == 'composite' %}
{{ encoding_composite__define_pack(type, schema) }}
  {% else %}
assert False, 'unknown type token ({{ type.token }})'
  {% endif %}
{% endmacro %}

{% macro encoding__invoke_pack(type, schema, arg_expr) %}
  {% if type.token == 'type' %}
{{ encoding_type__invoke_pack(type, schema, arg_expr) }}
  {% elif type.token == 'enum' %}
{{ encoding_enum__invoke_pack(type, schema, arg_expr) }}
  {% elif type.token == 'set' %}
{{ encoding_set__invoke_pack(type, schema, arg_expr) }}
  {% elif type.token == 'composite' %}
{{ encoding_composite__invoke_pack(type, schema, arg_expr) }}
  {% else %}
assert False, 'unknown type token ({{ type.token }})'
  {% endif %}
{% endmacro %}

{% macro encoding__define_unpack(type, schema) %}
  {% if type.token == 'type' %}
{{ encoding_type__define_unpack(type, schema) }}
  {% elif type.token == 'enum' %}
{{ encoding_enum__define_unpack(type, schema) }}
  {% elif type.token == 'set' %}
{{ encoding_set__define_unpack(type, schema) }}
  {% elif type.token == 'composite' %}
{{ encoding_composite__define_unpack(type, schema) }}
  {% else %}
assert False, 'unknown type token ({{ type.token }})'
  {% endif %}
{% endmacro %}

{% macro encoding__invoke_unpack(type, schema) %}
  {% if type.token == 'type' %}
{{ encoding_type__invoke_unpack(type, schema) }}
  {% elif type.token == 'enum' %}
{{ encoding_enum__invoke_unpack(type, schema) }}
  {% elif type.token == 'set' %}
{{ encoding_set__invoke_unpack(type, schema) }}
  {% elif type.token == 'composite' %}
{{ encoding_composite__invoke_unpack(type, schema) }}
  {% else %}
assert False, 'unknown type token ({{ type.token }})'
  {% endif %}
{% endmacro %}

{% macro field__define_pack(field, schema) %}
  {% set type = field.type -%}
  {% if type.token == 'type' %}
{{ encoding_type__define_pack(field, schema) }}
  {% elif type.token == 'enum' %}
{{ encoding_enum__define_pack(field, schema) }}
  {% elif type.token == 'set' %}
{{ encoding_set__define_pack(field, schema) }}
  {% elif type.token == 'composite' %}
{{ encoding_composite__define_pack(field, schema) }}
  {% else %}
assert False, 'unknown field type token ({{ type.token }})'
  {% endif %}
{% endmacro %}

{% macro field__invoke_pack(field, schema, arg_expr) %}
  {% set type = field.type -%}
  {% if type.token == 'type' %}
{{ encoding_type__invoke_pack(field, schema, arg_expr) }}
  {% elif type.token == 'enum' %}
{{ encoding_enum__invoke_pack(field, schema, arg_expr) }}
  {% elif type.token == 'set' %}
{{ encoding_set__invoke_pack(field, schema, arg_expr) }}
  {% elif type.token == 'composite' %}
{{ encoding_composite__invoke_pack(field, schema, arg_expr) }}
  {% else %}
assert False, 'unknown type token ({{ type.token }})'
  {% endif %}
{% endmacro %}

{% macro field__define_unpack(field, schema) %}
  {% set type = field.type -%}
  {% if type.token == 'type' %}
{{ encoding_type__define_unpack(field, schema) }}
  {% elif type.token == 'enum' %}
{{ encoding_enum__define_unpack(field, schema) }}
  {% elif type.token == 'set' %}
{{ encoding_set__define_unpack(field, schema) }}
  {% elif type.token == 'composite' %}
{{ encoding_composite__define_unpack(field, schema) }}
  {% else %}
assert False, 'unknown field type token ({{ type.token }})'
  {% endif %}
{% endmacro %}

{% macro field__invoke_unpack(field, schema) %}
  {% set type = field.type -%}
  {% if type.token == 'type' %}
{{ encoding_type__invoke_unpack(field, schema) }}
  {% elif type.token == 'enum' %}
{{ encoding_enum__invoke_unpack(field, schema) }}
  {% elif type.token == 'set' %}
{{ encoding_set__invoke_unpack(field, schema) }}
  {% elif type.token == 'composite' %}
{{ encoding_composite__invoke_unpack(field, schema) }}
  {% else %}
assert False, 'unknown type token ({{ type.token }})'
  {% endif %}
{% endmacro %}

{% macro data__define_pack(field, schema) %}
  {% set length = (field.type.contained_types | selectattr('name', 'equalto', 'length') | first) -%}
  {% set var_data = (field.type.contained_types | selectattr('name', 'equalto', 'varData') | first) -%}
  {% set primitive_type = 'char' if var_data.character_encoding and var_data.primitive_type.size == 1 else var_data.primitive_type.name | replace_keyword -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}

def pack_{{ make_encoding__suffix(field) }}(v):
  {% if primitive_type == 'char' %}
    length_codec = struct.Struct('{{ byte_order_flag }}{{ length.primitive_type.name | struct_fmt }}')
    raw_value = v.encode('{{ var_data.character_encoding }}')
    length_value = len(raw_value)
    length_codec.pack_into(ctx.buffer, ctx.offset, length_value)
    ctx.offset += length_codec.size
    data_codec = struct.Struct(f'{length_value}s')
    data_codec.pack_into(ctx.buffer, ctx.offset, raw_value)
    ctx.offset += data_codec.size
  {% else %}
    length_codec = struct.Struct('{{ byte_order_flag }}{{ length.primitive_type.name | struct_fmt }}')
    length_value = len(v)
    length_codec.pack_into(ctx.buffer, ctx.offset, length_value)
    ctx.offset += length_codec.size
    data_codec = struct.Struct(f'{length_value}{{ var_data.primitive_type.name | struct_fmt }}')
    data_codec.pack_into(ctx.buffer, ctx.offset, *v)
    ctx.offset += data_codec.size
  {% endif %}
{% endmacro %}

{% macro data__invoke_pack(field, schema, arg_expr) %}
pack_{{ make_encoding__suffix(field) }}({{ arg_expr }})
{% endmacro %}

{% macro data__define_unpack(field, schema) %}
  {% set length = (field.type.contained_types | selectattr('name', 'equalto', 'length') | first) -%}
  {% set var_data = (field.type.contained_types | selectattr('name', 'equalto', 'varData') | first) -%}
  {% set primitive_type = 'char' if var_data.character_encoding and var_data.primitive_type.size == 1 else var_data.primitive_type.name | replace_keyword -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}

def unpack_{{ make_encoding__suffix(field) }}():
  {% if primitive_type == 'char' %}
    length_codec = struct.Struct('{{ byte_order_flag }}{{ length.primitive_type.name | struct_fmt }}')
    length = length_codec.unpack_from(ctx.buffer, ctx.offset)[0]
    ctx.offset += length_codec.size
    data_codec = struct.Struct(f'{length}s')
    data = data_codec.unpack_from(ctx.buffer, ctx.offset)[0]
    ctx.offset += data_codec.size
    return data.decode('{{ var_data.character_encoding }}')
  {% else %}
    length_codec = struct.Struct('{{ byte_order_flag }}{{ length.primitive_type.name | struct_fmt }}')
    length = length_codec.unpack_from(ctx.buffer, ctx.offset)[0]
    ctx.offset += length_codec.size
    data_codec = struct.Struct(f'{{ byte_order_flag }}{length}{{ var_data.primitive_type.name | struct_fmt }}')
    data = data_codec.unpack_from(ctx.buffer, ctx.offset)
    ctx.offset += data_codec.size
    return list(data)
  {% endif %}
{% endmacro %}

{% macro data__invoke_unpack(field, schema) %}
unpack_{{ make_encoding__suffix(field) }}()
{% endmacro %}

{% macro group__define_pack(field, schema) %}
  {% set block_length_type = (field.dimension_type.contained_types | selectattr('name', 'equalto', 'blockLength') | first) -%}
  {% set num_in_group_type = (field.dimension_type.contained_types | selectattr('name', 'equalto', 'numInGroup') | first) -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}

def pack_{{ make_encoding__suffix(field) }}(v):
    # group {{ field.name }}
    assert isinstance(v, list), 'expected list type'

    {{ encoding__define_pack(block_length_type, schema).strip() | indent(4) }}
    {{ encoding__define_pack(num_in_group_type, schema).strip() | indent(4) }}

    count = len(v)

    {{ encoding__invoke_pack(block_length_type, schema, field.block_length).strip() | indent(4) }}
    {{ encoding__invoke_pack(num_in_group_type, schema, 'count').strip() | indent(4) }}

    ctx.offset += {{ field.dimension_type.encoded_length }}

    {% for field in field.fields %}
    {{ define__pack(field, schema).strip() | indent(4) }}
    {% endfor %}

    for entry in v:
    {% for field in field.fields if field.token == 'field' %}
      {% if field.presence in ('optional', 'constant') %}
        {{ invoke__pack(field, schema, 'entry.get(\'' ~ field.name ~ '\', None)').strip() | indent(8) }}
      {% else %}
        {{ invoke__pack(field, schema, 'entry.get(\'' ~ field.name ~ '\')').strip() | indent(8) }}
      {% endif %}
    {% endfor %}
        ctx.offset += {{ field.block_length }}
    {% for field in field.fields if field.token in ('group', 'data') %}
        {{ invoke__pack(field, schema, 'entry.get(\'' ~ field.name ~ '\')').strip() | indent(8) }}
    {% endfor %}
{% endmacro %}

{% macro group__invoke_pack(field, schema, arg_expr) %}
pack_{{ make_encoding__suffix(field) }}({{ arg_expr }})
{% endmacro %}

{% macro group__define_unpack(field, schema) %}
  {% set block_length_type = (field.dimension_type.contained_types | selectattr('name', 'equalto', 'blockLength') | first) -%}
  {% set num_in_group_type = (field.dimension_type.contained_types | selectattr('name', 'equalto', 'numInGroup') | first) -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}

def unpack_{{ make_encoding__suffix(field) }}():
    {{ encoding__define_unpack(block_length_type, schema).strip() | indent(4) }}
    {{ encoding__define_unpack(num_in_group_type, schema).strip() | indent(4) }}

    acting_block_length = {{ encoding__invoke_unpack(block_length_type, schema).strip() }}
    count = {{ encoding__invoke_unpack(num_in_group_type, schema).strip() }}

    ctx.offset += {{ field.dimension_type.encoded_length }}

    {% for field in field.fields %}
    {{ define__unpack(field, schema).strip() | indent(4) }}
    {% endfor %}

    value = list()
    for i in range(count):
        entry = {}
    {% for field in field.fields if field.token == 'field' %}
        entry['{{ field.name }}'] = {{ invoke__unpack(field, schema).strip() }}
    {% endfor %}
        ctx.offset += {{ field.block_length }}
    {% for field in field.fields if field.token in ('group', 'data') %}
        entry['{{ field.name }}'] = {{ invoke__unpack(field, schema).strip() }}
    {% endfor %}
        value.append(entry)

    return value

{% endmacro %}

{% macro group__invoke_unpack(field, schema) %}
unpack_{{ make_encoding__suffix(field) }}()
{% endmacro %}

{% macro define__pack(field, schema) %}
  {% if field.token == 'field' %}
{{ field__define_pack(field, schema) }}
  {% elif field.token == 'group' %}
{{ group__define_pack(field, schema) }}
  {% elif field.token == 'data' %}
{{ data__define_pack(field, schema) }}
  {% else %}
assert False, 'unknown entry token ({{ field.token }})'
  {% endif %}
{% endmacro %}

{% macro invoke__pack(field, schema, arg_expr) %}
  {% if field.token == 'field' %}
{{ field__invoke_pack(field, schema, arg_expr) }}
  {% elif field.token == 'group' %}
{{ group__invoke_pack(field, schema, arg_expr) }}
  {% elif field.token == 'data' %}
{{ data__invoke_pack(field, schema, arg_expr) }}
  {% else %}
assert False, 'unknown entry token ({{ field.token }})'
  {% endif %}
{% endmacro %}

{% macro define__unpack(field, schema) %}
  {% if field.token == 'field' %}
{{ field__define_unpack(field, schema) -}}
  {% elif field.token == 'group' %}
{{ group__define_unpack(field, schema) -}}
  {% elif field.token == 'data' %}
{{ data__define_unpack(field, schema) -}}
  {% else %}
assert False, 'unknown entry token ({{ field.token }})'
  {% endif %}
{% endmacro %}

{% macro invoke__unpack(field, schema) %}
  {% if field.token == 'field' %}
{{ field__invoke_unpack(field, schema) }}
  {% elif field.token == 'group' %}
{{ group__invoke_unpack(field, schema) }}
  {% elif field.token == 'data' %}
{{ data__invoke_unpack(field, schema) }}
  {% else %}
assert False, 'unknown entry token ({{ field.token }})'
  {% endif %}
{% endmacro %}

{% macro define_composite(field, schema) %}
  {% set class_name = field.name | format_composite_name -%}
  {% set type = field.type if field.token == 'field' else field -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}
  {% set is_optional = field.presence == 'optional' -%}

class {{ class_name }}:
    ENCODED_LENGTH = {{ field.encoded_length }}

    @staticmethod
    def pack(ctx: CodecContext, value: Any) -> None:
  {% for field in type.contained_types %}
        {{ encoding__define_pack(field, schema).strip() | indent(8) }}
  {% endfor %}

  {% if is_optional %}
        if not v:
            {{ encoding__invoke_pack(field, schema, 'None').strip() | indent(12) }}
            return
  {% endif %}
  {% for field in type.contained_types %}
    {% if field.presence in ('optional', 'constant') %}
        {{ encoding__invoke_pack(field, schema, 'value.get(\'' ~ field.reference_name ~ '\', None)').strip() | indent(8) }}
    {% elif field.presence == 'required' %}
        {{ encoding__invoke_pack(field, schema, 'value.get(\'' ~ field.reference_name ~ '\')').strip() | indent(8) }}
    {% endif %}
  {% endfor %}

    @staticmethod
    def unpack(ctx: CodecContext) -> Any:
  {% for field in type.contained_types %}
        {{ encoding__define_unpack(field, schema).strip() | indent(8) }}
  {% endfor %}

        value0 = {{ encoding__invoke_unpack(type.contained_types[0], schema).strip() }}
  {% if is_optional %}
        if not value0:
            return None
  {% endif %}
        value = { '{{ type.contained_types[0].reference_name }}': value0 }
  {% for field in type.contained_types %}
    {% if loop.index0 != 0 %}
        value['{{ field.reference_name }}'] = {{ encoding__invoke_unpack(field, schema).strip() }}
    {% endif %}
  {% endfor %}
        return value
{% endmacro %}

{% macro define_message(message, schema) %}
  {% set class_name = message.name | format_message_name -%}

class {{ class_name }}:
    TEMPLATE_ID = {{ message.id }}
    BLOCK_LENGTH = {{ message.block_length }}

  {% if message.fields | length == 0 %}
    @staticmethod
    def pack(ctx: CodecContext, value: Any, acting_block_length: int = {{ message.block_length }}) -> None:
        pass

    @staticmethod
    def unpack(ctx: CodecContext, acting_block_length: int = {{ message.block_length }}) -> Any:
        return {}
  {% else %}
    @staticmethod
    def pack(ctx: CodecContext, value: Any, acting_block_length: int = {{ message.block_length }}) -> None:
    {% for field in message.fields %}
        {{ define__pack(field, schema).strip() | indent(8) }}
    {% endfor %}

        assert acting_block_length >= {{ message.block_length }}, 'invalid acting_block_length value'

    {% for field in message.fields if field.token == 'field' %}
      {% if field.presence in ('optional', 'constant') %}
        {{ invoke__pack(field, schema, 'value.get(\'' ~ field.name ~ '\', None)').strip() | indent(8) }}
      {% else %}
        {{ invoke__pack(field, schema, 'value.get(\'' ~ field.name ~ '\')').strip() | indent(8) }}
      {% endif %}
    {% endfor %}
        ctx.offset += acting_block_length
    {% for field in message.fields if field.token in ('group', 'data') %}
        {{ invoke__pack(field, schema, 'value.get(\'' ~ field.name ~ '\')').strip() | indent(8) }}
    {% endfor %}

    @staticmethod
    def unpack(ctx: CodecContext, acting_block_length: int = {{ message.block_length }}) -> Any:
    {% for field in message.fields %}
        {{ define__unpack(field, schema).strip() | indent(8) }}
    {% endfor %}

        assert acting_block_length >= {{ message.block_length }}, 'invalid acting_block_length value'

        value = {}
    {% for field in message.fields if field.token == 'field'%}
        value['{{ field.name }}'] = {{ invoke__unpack(field, schema).strip() }}
    {% endfor %}
        ctx.offset += acting_block_length
    {% for field in message.fields if field.token in ('group', 'data') %}
        value['{{ field.name }}'] = {{ invoke__unpack(field, schema).strip() }}
    {% endfor %}
        return value
  {% endif %}
{% endmacro %}
