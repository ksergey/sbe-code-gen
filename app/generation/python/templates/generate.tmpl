{% macro define_enum(type, schema) %}
{% set enum_class_name = type.name | format_class_name %}
class {{ enum_class_name }}(Enum):
{% for valid_value in type.valid_values %}
    {% if type.encoding_type.name == 'char' %}
    {{ valid_value.name | upper }} = '{{ valid_value.value }}'
    {% else %}
    {{ valid_value.name | upper }} = {{ valid_value.value }}
    {% endif %}
{% endfor %}
{% endmacro %}

{% macro define_set(type, schema) %}
{% set set_class_name = type.name | format_class_name %}
class {{ set_class_name }}(Flag):
{% for choice in type.choices %}
    {{ choice.name | upper }} = {{ choice.value | bit_to_value}}
{% endfor %}
{% endmacro %}

{% macro make_encoding__suffix(field) -%}
  {% if field.reference_name  %}
{{- field.reference_name -}}
  {% else %}
{{- field.name -}}
  {% endif %}
{%- endmacro %}

{% macro define_type_encoding_type__pack(field, schema) %}
  {% set type = field.type if field.token == 'field' else field -%}
  {% set primitive_type = type.primitive_type -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}
  {% set is_string = primitive_type == 'char' -%}
  {% set is_optional = field.presence == 'optional' -%}
def pack_{{ make_encoding__suffix(field) }}(v):
  {% if field.presence == 'required' and type.length == 1 %}
    struct.pack_into('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }}, v)
  {% endif %}
  {% if field.presence == 'optional' and type.length == 1 %}
    struct.pack_into('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }}, v if v else {{ type.null_value | replace_keyword }})
  {% endif %}
  {% if field.presence == 'required' and type.length > 1 %}
    {% if is_string %}
    raw_value = v.encode('utf-8')
    assert len(raw_value) <= {{ type.length }}, 'argument length mismatch'
    if len(raw_value) < {{ type.length }}:
        raw_value += b'\{{ type.null_value | replace_keyword }}' * ({{ type.length }} - len(raw_value))
    struct.pack_into('{{ type.length }}s', ctx.buffer, ctx.offset + {{ field.offset }}, raw_value)
    {% else %}
    assert len(v) == {{ type.length }}, 'argument length mismatch'
    struct.pack_into('{{ byte_order_flag }}{{ type.length }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }}, *v)
    {% endif %}
  {% endif %}
  {% if field.presence == 'optional' and type.length > 1 %}
    {% if is_string %}
    if v:
        raw_value = v.encode('utf-8')
        assert len(raw_value) <= {{ type.length }}, 'argument length mismatch'
    else:
        raw_value = b''
    if len(raw_value) < {{ type.length }}:
        raw_value += b'\{{ type.null_value | replace_keyword }}' * ({{ type.length }} - len(raw_value))
    struct.pack_into('{{ type.length }}s', ctx.buffer, ctx.offset + {{ field.offset }}, raw_value)
    {% else %}
    if v:
        assert len(v) == {{ type.length }}, 'argument length mismatch'
        struct.pack_into('{{ byte_order_flag }}{{ type.length }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }}, *v)
    else:
        struct.pack_into('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }}, {{ type.null_value | replace_keyword }})
    {% endif %}
  {% endif %}
  {% if field.presence == 'constant' %}
    assert not v or v == {{ type.const_value | replace_keyword }}
  {% endif %}
{% endmacro %}

{% macro define_type_encoding_type__unpack(field, schema) %}
  {% set type = field.type if field.token == 'field' else field -%}
  {% set primitive_type = type.primitive_type -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}
  {% set is_string = primitive_type == 'char' -%}
  {% set is_optional = field.presence == 'optional' -%}

def unpack_{{ make_encoding__suffix(field) }}():
  {% if field.presence == 'required' and type.length == 1 %}
    return struct.unpack_from('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }})[0]
  {% endif %}
  {% if field.presence == 'optional' and type.length == 1 %}
    raw_value = struct.unpack_from('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }})
    if raw_value == {{ type.null_value | replace_keyword }}:
        return None
    return raw_value
  {% endif %}
  {% if field.presence == 'required' and type.length > 1 %}
    {% if is_string %}
    raw_value = struct.unpack_from('{{ type.length }}s', ctx.buffer, ctx.offset + {{ field.offset }})[0]
    return raw_value.decode('utf-8').rstrip(chr({{ type.null_value | replace_keyword }}))
    {% else %}
    return list(struct.unpack_from('{{ byte_order_flag }}{{ type.length }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }})
    {% endif %}
  {% endif %}
  {% if field.presence == 'optional' and type.length > 1 %}
    {% if is_string %}
    raw_value = struct.unpack_from('{{ type.length }}s', ctx.buffer, ctx.offset + {{ field.offset }})[0]
    if raw_value[0] == {{ type.null_value }}:
        return None
    return raw_value.decode('utf-8').rstrip(chr({{ type.null_value | replace_keyword }}))
    {% else %}
    raw_value = struct.unpack_from('{{ byte_order_flag }}{{ type.length }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }})
    if raw_value[0] == {{ type.null_value | replace_keyword }}:
        return None
    return list(raw_value)
    {% endif %}
  {% endif %}
  {% if field.presence == 'constant' %}
    return {{ type.const_value }}
  {% endif %}
{% endmacro %}

{% macro define_type_encoding_enum__pack(field, schema) %}
  {% set type = field.type if field.token == 'field' else field -%}
  {% set primitive_type = type.encoding_type -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}

def pack_{{ make_encoding__suffix(field) }}(v):
  {% if field.presence == 'required' %}
    assert isinstance(v, Enum)
    struct.pack_into('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }}, v.value)
  {% endif %}
  {% if field.presence == 'optional' %}
    assert not v or isinstance(v, Enum)
    struct.pack_into('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }}, v.value if v else {{ type.null_value | replace_keyword }})
  {% endif %}
  {% if field.presence == 'constant' %}
    # TODO
    assert not v or isinstance(v, Enum)
  {% endif %}
{% endmacro %}

{% macro define_type_encoding_enum__unpack(field, schema) %}
  {% set type = field.type if field.token == 'field' else field -%}
  {% set primitive_type = type.encoding_type -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}

def unpack_{{ make_encoding__suffix(field) }}():
  {% if field.presence == 'required' %}
    return {{ type.name | format_class_name }}(struct.unpack_from('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }})[0])
  {% endif %}
  {% if field.presence == 'optional' %}
    raw_value = struct.unpack_from('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }})[0]
    if raw_value == {{ type.null_value | replace_keyword }}:
        return None
    return {{ type.name | format_class_name}}(raw_value)
  {% endif %}
  {% if field.presence == 'constant' %}
    return {{ field.value_ref }} # TODO?
  {% endif %}
{% endmacro %}

{% macro define_type_encoding_set__pack(field, schema) %}
  {% set type = field.type if field.token == 'field' else field -%}
  {% set primitive_type = type.encoding_type -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}

def pack_{{ make_encoding__suffix(field) }}(v):
  {% if field.presence == 'required' %}
    assert isinstance(v, Flag)
    struct.pack_into('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }}, v.value)
  {% endif %}
{% endmacro %}

{% macro define_type_encoding_set__unpack(field, schema) %}
  {% set type = field.type if field.token == 'field' else field -%}
  {% set primitive_type = type.encoding_type -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}

def unpack_{{ make_encoding__suffix(field) }}():
  {% if field.presence == 'required' %}
    return {{ type.name | format_class_name }}(struct.unpack_from('{{ byte_order_flag }}{{ primitive_type.name | struct_fmt }}', ctx.buffer, ctx.offset + {{ field.offset }})[0])
  {% endif %}
{% endmacro %}

{% macro define_type_encoding_composite__pack(field, schema) %}
  {% set type = field.type if field.token == 'field' else field -%}
  {% set is_optional = field.presence == 'optional' -%}

def pack_{{ make_encoding__suffix(field) }}(v):
  {% for field in type.contained_types %}
    {{ define_type_encoding__pack(field, schema) | indent(4) -}}
  {% endfor %}

  {% if is_optional %}
    if not v:
        pack_{{ make_encoding__suffix(type.contained_types[0]) }}(None)
        return
  {% endif %}
  {% for field in type.contained_types %}
    {% if field.presence in ('optional', 'constant') %}
        pack_{{ make_encoding__suffix(field) }}(value.get('{{ field.reference_name }}', None))
    {% elif field.presence == 'required' %}
        pack_{{ make_encoding__suffix(field) }}(value.get('{{ field.reference_name }}'))
    {% endif %}
  {% endfor %}
{% endmacro %}

{% macro define_type_encoding_composite__unpack(field, schema) %}
  {% set type = field.type if field.token == 'field' else field -%}
  {% set is_optional = field.presence == 'optional' -%}

def unpack_{{ make_encoding__suffix(field) }}():
  {% for field in type.contained_types %}
    {{ define_type_encoding__unpack(field, schema) | indent(4) -}}
  {% endfor %}

    value0 = unpack_{{ make_encoding__suffix(type.contained_types[0]) }}()
  {% if is_optional %}
    if not value0:
        return None
  {% endif %}
    return {
        '{{ type.contained_types[0].reference_name }}': value0,
  {% for field in type.contained_types %}
    {% if loop.index0 != 0 %}
        '{{ field.reference_name }}': unpack_{{ make_encoding__suffix(field) }}(),
    {% endif %}
  {% endfor %}
{% endmacro %}

{% macro define_type_encoding__pack(type, schema) %}
  {% if type.token == 'type' %}
{{ define_type_encoding_type__pack(type, schema) -}}
  {% elif type.token == 'enum' %}
{{ define_type_encoding_enum__pack(type, schema) -}}
  {% elif type.token == 'set' %}
{{ define_type_encoding_set__pack(type, schema) -}}
  {% elif type.token == 'composite' %}
{{ define_type_encoding_composite__pack(type, schema) -}}
  {% else %}
assert False, 'unknown type token ({{ type.token }})'
  {% endif %}
{% endmacro %}

{% macro define_type_encoding__unpack(type, schema) %}
  {% if type.token == 'type' %}
{{ define_type_encoding_type__unpack(type, schema) -}}
  {% elif type.token == 'enum' %}
{{ define_type_encoding_enum__unpack(type, schema) -}}
  {% elif type.token == 'set' %}
{{ define_type_encoding_set__unpack(type, schema) -}}
  {% elif type.token == 'composite' %}
{{ define_type_encoding_composite__unpack(type, schema) -}}
  {% else %}
assert False, 'unknown type token ({{ type.token }})'
  {% endif %}
{% endmacro %}

{% macro define_field_encoding__pack(field, schema) %}
  {% set type = field.type -%}
  {% if type.token == 'type' %}
{{ define_type_encoding_type__pack(field, schema) -}}
  {% elif type.token == 'enum' %}
{{ define_type_encoding_enum__pack(field, schema) -}}
  {% elif type.token == 'set' %}
{{ define_type_encoding_set__pack(field, schema) -}}
  {% elif type.token == 'composite' %}
{{ define_type_encoding_composite__pack(field, schema) -}}
  {% else %}
assert False, 'unknown field type token ({{ type.token }})'
  {% endif %}
{% endmacro %}

{% macro define_field_encoding__unpack(field, schema) %}
  {% set type = field.type -%}
  {% if type.token == 'type' %}
{{ define_type_encoding_type__unpack(field, schema) -}}
  {% elif type.token == 'enum' %}
{{ define_type_encoding_enum__unpack(field, schema) -}}
  {% elif type.token == 'set' %}
{{ define_type_encoding_set__unpack(field, schema) -}}
  {% elif type.token == 'composite' %}
{{ define_type_encoding_composite__unpack(field, schema) -}}
  {% else %}
assert False, 'unknown field type token ({{ type.token }})'
  {% endif %}
{% endmacro %}

{% macro define_data_encoding__pack(field, schema) %}
  {% set length = (field.type.contained_types | selectattr('name', 'equalto', 'length') | first) -%}
  {% set var_data = (field.type.contained_types | selectattr('name', 'equalto', 'varData') | first) -%}
  {% set primitive_type = 'char' if var_data.character_encoding and var_data.primitive_type.size == 1 else var_data.primitive_type.name | replace_keyword -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}

def pack_{{ make_encoding__suffix(field) }}(v):
  {% if primitive_type == 'char' %}
    length_codec = struct.Struct('{{ byte_order_flag }}{{ length.primitive_type.name | struct_fmt }}')
    raw_value = v.encode('{{ var_data.character_encoding }}')
    length_codec.pack_into(ctx.buffer, ctx.offset, len(raw_value))
    ctx.offset += length_codec.size
    data_codec = struct.Struct(f'{len(raw_value)}s')
    data_codec.pack_into(ctx.buffer, ctx.offset, raw_value)
    ctx.offset += data_codec.size
  {% else %}
    length_codec = struct.Struct('{{ byte_order_flag }}{{ length.primitive_type.name | struct_fmt }}')
    length_codec.pack_into(ctx.buffer, ctx.offset, len(v))
    ctx.offset += length_codec.size
    data_codec = struct.Struct(f'{len(v)}{{ var_data.primitive_type.name | struct_fmt }}')
    data_codec.pack_into(ctx.buffer, ctx.offset, *v)
    ctx.offset += data_codec.size
  {% endif %}
{% endmacro %}

{% macro define_data_encoding__unpack(field, schema) %}
  {% set length = (field.type.contained_types | selectattr('name', 'equalto', 'length') | first) -%}
  {% set var_data = (field.type.contained_types | selectattr('name', 'equalto', 'varData') | first) -%}
  {% set primitive_type = 'char' if var_data.character_encoding and var_data.primitive_type.size == 1 else var_data.primitive_type.name | replace_keyword -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}

def unpack_{{ make_encoding__suffix(field) }}():
  {% if primitive_type == 'char' %}
    length_codec = struct.Struct('{{ byte_order_flag }}{{ length.primitive_type.name | struct_fmt }}')
    length = length_codec.unpack_from(ctx.buffer, ctx.offset)[0]
    ctx.offset += length_codec.size
    data_codec = struct.Struct(f'{length}s')
    data = data_codec.unpack_from(ctx.buffer, ctx.offset)[0]
    ctx.offset += data_codec.size
    return data.decode('{{ var_data.character_encoding }}')
  {% else %}
    length_codec = struct.Struct('{{ byte_order_flag }}{{ length.primitive_type.name | struct_fmt }}')
    length = length_codec.unpack_from(ctx.buffer, ctx.offset)[0]
    ctx.offset += length_codec.size
    data_codec = struct.Struct(f'{{ byte_order_flag }}{length}{{ var_data.primitive_type.name | struct_fmt }}')
    data = data_codec.unpack_from(ctx.buffer, ctx.offset)
    ctx.offset += data_codec.size
    return list(data)
  {% endif %}
{% endmacro %}

{% macro define_group_encoding__pack(field, schema) %}
  {% set block_length_type = (field.dimension_type.contained_types | selectattr('name', 'equalto', 'blockLength') | first) -%}
  {% set num_in_group_type = (field.dimension_type.contained_types | selectattr('name', 'equalto', 'numInGroup') | first) -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}

def pack_{{ make_encoding__suffix(field) }}(v):
    # group {{ field.name }}
    assert isinstance(v, list), 'expected list type'

    {{ define_type_encoding__pack(block_length_type, schema) | indent(4) }}
    {{ define_type_encoding__pack(num_in_group_type, schema) | indent(4) }}

    count = len(v)

    pack_{{ make_encoding__suffix(block_length_type) }}({{ field.block_length }})
    pack_{{ make_encoding__suffix(num_in_group_type) }}(count)

    ctx.offset += {{ field.dimension_type.encoded_length }}

    {% for field in field.fields %}
    {{ define_encoding__pack(field, schema) | indent(4) -}}
    {% endfor %}

    for entry in v:
    {% for field in field.fields if field.token == 'field' %}
        pack_{{ make_encoding__suffix(field) }}(entry.get('{{ field.name }}'))
    {% endfor %}
        ctx.offset += {{ field.block_length }}
    {% for field in field.fields if field.token in ('group', 'data') %}
        pack_{{ make_encoding__suffix(field) }}(entry.get('{{ field.name }}'))
    {% endfor %}

{% endmacro %}

{% macro define_group_encoding__unpack(field, schema) %}
  {% set block_length_type = (field.dimension_type.contained_types | selectattr('name', 'equalto', 'blockLength') | first) -%}
  {% set num_in_group_type = (field.dimension_type.contained_types | selectattr('name', 'equalto', 'numInGroup') | first) -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}

def unpack_{{ make_encoding__suffix(field) }}():
    {{ define_type_encoding__unpack(block_length_type, schema) | indent(4) }}
    {{ define_type_encoding__unpack(num_in_group_type, schema) | indent(4) }}

    acting_block_length = unpack_{{ make_encoding__suffix(block_length_type) }}()
    count = unpack_{{ make_encoding__suffix(num_in_group_type) }}()

    ctx.offset += {{ field.dimension_type.encoded_length }}

    {% for field in field.fields %}
    {{ define_encoding__unpack(field, schema) | indent(4) -}}
    {% endfor %}

    value = list()

    for i in range(count):
        entry = {}
    {% for field in field.fields if field.token == 'field' %}
        entry['{{ field.name }}'] = unpack_{{ make_encoding__suffix(field) }}()
    {% endfor %}
        ctx.offset += {{ field.block_length }}
    {% for field in field.fields if field.token in ('group', 'data') %}
        entry['{{ field.name }}'] = unpack_{{ make_encoding__suffix(field) }}()
    {% endfor %}
        value.append(entry)

    return value

{% endmacro %}

{% macro define_encoding__pack(field, schema) %}
  {% if field.token == 'field' %}
{{ define_field_encoding__pack(field, schema) -}}
  {% elif field.token == 'group' %}
{{ define_group_encoding__pack(field, schema) -}}
  {% elif field.token == 'data' %}
{{ define_data_encoding__pack(field, schema) -}}
  {% else %}
assert False, 'unknown entry token ({{ field.token }})'
  {% endif %}
{% endmacro %}

{% macro define_encoding__unpack(field, schema) %}
  {% if field.token == 'field' %}
{{ define_field_encoding__unpack(field, schema) -}}
  {% elif field.token == 'group' %}
{{ define_group_encoding__unpack(field, schema) -}}
  {% elif field.token == 'data' %}
{{ define_data_encoding__unpack(field, schema) -}}
  {% else %}
assert False, 'unknown entry token ({{ field.token }})'
  {% endif %}
{% endmacro %}

{% macro define_composite(field, schema) %}
  {% set class_name = field.name | format_class_name -%}
  {% set type = field.type if field.token == 'field' else field -%}
  {% set byte_order_flag = '<' if schema.byte_order == 'littleEndian' else '>' -%}
  {% set is_optional = field.presence == 'optional' -%}

class {{ class_name }}(Codec):
    @staticmethod
    def pack(ctx: CodecContext, value: Any) -> None:
  {% for field in type.contained_types %}
        {{ define_type_encoding__pack(field, schema) | indent(8) -}}
  {% endfor %}

  {% if is_optional %}
        if not v:
            pack_{{ make_encoding__suffix(type.contained_types[0]) }}(None)
            return
  {% endif %}
  {% for field in type.contained_types %}
    {% if field.presence in ('optional', 'constant') %}
        pack_{{ make_encoding__suffix(field) }}(value.get('{{ field.reference_name }}', None))
    {% elif field.presence == 'required' %}
        pack_{{ make_encoding__suffix(field) }}(value.get('{{ field.reference_name }}'))
    {% endif %}
  {% endfor %}

    @staticmethod
    def unpack(ctx: CodecContext) -> Any:
  {% for field in type.contained_types %}
        {{ define_type_encoding__unpack(field, schema) | indent(8) -}}
  {% endfor %}

        value0 = unpack_{{ make_encoding__suffix(type.contained_types[0]) }}()
  {% if is_optional %}
        if not value0:
            return None
  {% endif %}
        return {
            '{{ type.contained_types[0].reference_name }}': value0,
  {% for field in type.contained_types %}
    {% if loop.index0 != 0 %}
            '{{ field.reference_name }}': unpack_{{ make_encoding__suffix(field) }}(),
    {% endif %}
  {% endfor %}
        }

    def __repr__(self) -> str:
        return f'<{{ class_name }}>'
{% endmacro %}

{% macro define_message(message, schema) %}
{% set class_name = message.name | format_message_name -%}

class {{ class_name }}(Codec):
  {% if message.fields | length  == 0 %}
    @staticmethod
    def pack(ctx: CodecContext, value: Any, acting_block_length: int = {{ message.block_length }}) -> None:
        pass

    @staticmethod
    def unpack(ctx: CodecContext, acting_block_length: int = {{ message.block_length }}) -> Any:
        return {}
  {% else %}
    @staticmethod
    def pack(ctx: CodecContext, value: Any, acting_block_length: int = {{ message.block_length }}) -> None:
    {% for field in message.fields %}
        {{ define_encoding__pack(field, schema) | indent(8) -}}
    {% endfor %}

        assert acting_block_length >= {{ message.block_length }}, 'invalid acting_block_length value'

    {% for field in message.fields if field.token == 'field' %}
      {# TODO: presence check for <field> #}
        pack_{{ make_encoding__suffix(field) }}(value.get('{{ field.name }}'))
    {% endfor %}
        ctx.offset += acting_block_length
    {% for field in message.fields if field.token in ('group', 'data') %}
      {# TODO: presence check for <field> #}
        pack_{{ make_encoding__suffix(field) }}(value.get('{{ field.name }}'))
    {% endfor %}

    @staticmethod
    def unpack(ctx: CodecContext, acting_block_length: int = {{ message.block_length }}) -> Any:
    {% for field in message.fields %}
        {{ define_encoding__unpack(field, schema) | indent(8) -}}
    {% endfor %}

        assert acting_block_length >= {{ message.block_length }}, 'invalid acting_block_length value'

        value = {}
    {% for field in message.fields if field.token == 'field'%}
        value['{{ field.name }}'] = unpack_{{ make_encoding__suffix(field) }}()
    {% endfor %}
        ctx.offset += acting_block_length
    {% for field in message.fields if field.token in ('group', 'data') %}
        value['{{ field.name }}'] = unpack_{{ make_encoding__suffix(field) }}()
    {% endfor %}
        return value
  {% endif %}

    def __repr__(self) -> str:
        return f'<{{ class_name }}>'
{% endmacro %}
