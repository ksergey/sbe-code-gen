{% import 'generate.tmpl' as generate %}
import struct
import sys

from enum import Enum, Flag
from typing import Any, Union, Optional

# Codec encode/decode context
class CodecContext:
    def __init__(self, buffer: Union[bytes, bytearray, memoryview], offset: int = 0) -> None:
        self.buffer = buffer
        self.offset = offset

{% for type in schema.types %}
  {% if type.token == 'composite' and type.name == 'messageHeader' %}
{{ generate.define_composite(type, schema) }}
  {% elif type.token == 'enum' %}
{{ generate.define_enum(type, schema) }}
  {% elif type.token == 'set' %}
{{ generate.define_set(type, schema) }}
  {% endif %}
{% endfor %}

{% for message in schema.messages %}
{{ generate.define_message(message, schema) }}
{% endfor %}

class Schema:
    SCHEMA_ID = {{ schema.id }}
    VERSION = {{ schema.version }}

    MESSAGES = dict([
{% for message in schema.messages %}
        ({{ message.id }}, {{ message.name | format_message_name }}),
{% endfor %}
    ])

    @staticmethod
    def getCodecCls(template_id: int):
        codec = Schema.MESSAGES.get(template_id)
        if not codec:
            raise Exception(f'codec for message with templateId={template_id} not found')
        return codec

    @staticmethod
    def encode(ctx: CodecContext, value: Any, *, cls=None, template_id: Optional[int] = None) -> None:
        assert cls or template_id, 'cls or template_id argument required'
        if not cls:
            cls = Schema.getCodecCls(template_id)
        MessageHeader.pack(ctx, {
            'blockLength': cls.BLOCK_LENGTH,
            'templateId': cls.TEMPLATE_ID,
            'schemaId': {{ schema.id }},
            'version': {{ schema.version }}
        })
        ctx.offset += MessageHeader.ENCODED_LENGTH
        return cls.pack(ctx, value)

    @staticmethod
    def decode(ctx: CodecContext) -> Any:
        header = MessageHeader.unpack(ctx)
        cls = Schema.getCodecCls(header.get('templateId'))
        ctx.offset += MessageHeader.ENCODED_LENGTH
        return cls.unpack(ctx, header.get('blockLength'))

# Example
#
# create CodecContext:
# buffer = bytearray(64)
# ctx = CodecContext(buffer)
#
# encode:
# Schema.encode(ctx, { 'nextSeqNo': 1234 }, template_id=2)
# ... or ...
# Schema.encode(ctx, { 'nextSeqNo': 1234 }, cls=Sequence_2Message)
# print(f'encoded size: {ctx.offset}')
#
# decode:
# ctx.offset = 0 # reset cursor
# print(Schema.decode(ctx))

